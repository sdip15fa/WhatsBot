//jshint esversion:8
// code generated by chatgpt, fixed by wcyat
import whatsapp, { Client, Message } from "whatsapp-web.js";
const { MessageMedia } = whatsapp;
import { Chess } from "chess.js";
import { spawn } from "child_process";
import db from "../db/index.js";
import ChessImageGenerator from "@newyork.anthonyng/chess-image-generator";

const execute = async (client: Client, msg: Message, args: string[]) => {
  const chatId = (await msg.getChat()).id._serialized;
  const command = args[0];

  const chessDoc = await db("chess").coll.findOne({ chatId });
  const fen = chessDoc?.fen;

  if (command === "start") {
    if (fen) {
      await db("chess").coll.deleteOne({ chatId });
    }

    const chess = new Chess();
    await db("chess").coll.insertOne({ chatId, fen: chess.fen() });

    client.sendMessage(chatId, "New Chess game started.");
    printBoard(client, chatId, chess);
    return;
  }

  if (command === "move") {
    const chess = new Chess(fen);
    const move = args.slice(1).join(" ");

    try {
      chess.move(move);
      client.sendMessage(chatId, "You played: " + move);
      // printBoard(client, chatId, chess);

      if (chess.isGameOver()) {
        const result = chess.isCheckmate() ? "Checkmate!" : "Stalemate!";
        client.sendMessage(chatId, result + " Game over.");
        return await db("chess").coll.deleteOne({ chatId });
      }

      await makeComputerMove(client, chatId, chess, chessDoc.depth || 15);
      printBoard(client, chatId, chess);

      if (chess.isGameOver()) {
        const result = chess.isCheckmate() ? "Checkmate!" : "Stalemate!";
        client.sendMessage(chatId, result + " Game over.");
        return await db("chess").coll.deleteOne({ chatId });
      }

      await db("chess").coll.updateOne(
        { chatId },
        { $set: { fen: chess.fen() } }
      );

      return;
    } catch {
      client.sendMessage(
        chatId,
        "Invalid move. Please provide a valid move in algebraic notation (e.g., e2e4)."
      );
      return;
    }
  }

  if (command === "depth") {
    const depth = parseInt(args[1]);
    if (isNaN(depth) || depth < 10 || depth > 20) {
      client.sendMessage(chatId, "Invalid depth. Valid depths are 11-20.");
      return;
    }
    await db("chess").coll.updateOne({ chatId }, { $set: { depth } });
    client.sendMessage(chatId, "Depth set to " + depth);
    return;
  }

  client.sendMessage(
    chatId,
    "Invalid command. Use `!chess start` to start a new game or `!chess depth [10-20]` to set stockfish depth or `!chess move [move]` to make a move."
  );
};
const printBoard = async (client: Client, chatId: string, chess: Chess) => {
  const imageGenerator = new ChessImageGenerator();
  await imageGenerator.loadFEN(chess.fen());
  const image: Buffer = await imageGenerator.generateBuffer();

  client.sendMessage(
    chatId,
    new MessageMedia("image/png", image.toString("base64"), chess.fen())
  );
};

const makeComputerMove = async (
  client: Client,
  chatId: string,
  chess: Chess,
  depth = 15
) => {
  const fen = chess.fen();
  const bestMove: string = await getBestMove(fen, depth);

  if (bestMove) {
    chess.move(bestMove);
    client.sendMessage(chatId, "Computer played: " + bestMove);
  } else {
    client.sendMessage(chatId, "Computer failed to make a move.");
  }
};

async function getBestMove(fen: string, depth = 15): Promise<string> {
  return await new Promise((resolve, reject) => {
    const stockfishPath = "/usr/games/stockfish";
    const stockfish = spawn(stockfishPath);
    const moves: string[] = [];
    let movesLength = 0;

    let bestMove = "";

    stockfish.stdout.on("data", (data) => {
      const output: string = data.toString();

      output.split("\n").forEach((line) => {
        if (line.includes("bestmove")) {
          const parts = line.split(" ");
          bestMove = parts[1].trim();
          moves.push(bestMove);
          // resolve(bestMove);
        }
      });
    });

    stockfish.stdout.on("exit", (code) => {
      if (code !== 0) {
        reject(`Stockfish exited with code ${code}.`);
      }
      // resolve(bestMove);
    });

    stockfish.stdin.write("uci\n");
    stockfish.stdin.write(`position fen ${fen}\n`);
    stockfish.stdin.write(`go depth ${depth}\n`);
    // stockfish.stdin.write("quit\n");

    (async () => {
      while (movesLength !== moves.length || moves.length == 0) {
        movesLength = moves.length;
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
      resolve(moves[moves.length - 1]);
    })();
  });
}

export default {
  name: "chess",
  command: "!chess",
  description: "Play a game of Chess!",
  commandType: "plugin",
  isDependent: false,
  help: `*Chess Game Commands*:
  • Start a game: \`!chess start\`
  • Make a move: \`!chess move [move]\`
  • Help: \`!chess help\`
  `,
  execute,
  public: true,
};
