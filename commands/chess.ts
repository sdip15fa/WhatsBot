//jshint esversion:8
// code generated by chatgpt, fixed by wcyat
import whatsapp, { Client, Message } from "whatsapp-web.js";
import { sendLocalized } from "../helpers/localizedMessenger.js";
import { Command } from "../types/command.js";
const { MessageMedia } = whatsapp;
import { Chess } from "chess.js";
import { spawn } from "child_process";
import db from "../db/index.js";
import ChessImageGenerator from "@newyork.anthonyng/chess-image-generator";

const execute = async (client: Client, msg: Message, args: string[]) => {
  const chat = await msg.getChat();
  const chatId = chat.id._serialized;
  const command = args[0];

  const chessDoc = await db("chess").coll.findOne({ chatId });
  const mode =
    (await db("chats").coll.findOne({ chatId }))?.chess?.mode ||
    (chat.isGroup ? "pvp" : "pvc");
  const fen = chessDoc?.fen;

  if (command === "start") {
    if (fen) {
      await db("chess").coll.deleteOne({ chatId });
    }

    const chess = new Chess();
    await db("chess").coll.insertOne({ chatId, fen: chess.fen() });

    sendLocalized(client, msg, "chess.gameStarted");
    printBoard(client, chatId, chess);
    return;
  }

  if (command === "move") {
    const chess = new Chess(fen);
    const move = args.slice(1).join(" ");

    try {
      chess.move(move);
      sendLocalized(client, msg, "chess.playerPlayed", {
        player: chess.moveNumber() % 2 ? "White" : "Black",
        moveNumber: chess.moveNumber(),
        move: move,
      });
      // printBoard(client, chatId, chess);

      if (chess.isGameOver()) {
        const result = chess.isCheckmate() ? "Checkmate!" : "Stalemate!";
        sendLocalized(client, msg, "chess.gameOver", { result: result });
        return await db("chess").coll.deleteOne({ chatId });
      }

      if (mode === "pvc") {
        await makeComputerMove(
          client,
          msg,
          chatId,
          chess,
          chessDoc?.depth || 15,
        );
      }
      printBoard(client, chatId, chess);

      if (chess.isGameOver()) {
        const result = chess.isCheckmate() ? "Checkmate!" : "Stalemate!";
        sendLocalized(client, msg, "chess.gameOver", { result: result });
        return await db("chess").coll.deleteOne({ chatId });
      }

      await db("chess").coll.updateOne(
        { chatId },
        { $set: { fen: chess.fen() } },
      );

      return;
    } catch {
      sendLocalized(client, msg, "chess.invalidMove");
      return;
    }
  }

  if (command === "depth") {
    const depth = parseInt(args[1]);
    if (isNaN(depth) || depth < 10 || depth > 20) {
      sendLocalized(client, msg, "chess.invalidDepth");
      return;
    }
    await db("chess").coll.updateOne({ chatId }, { $set: { depth } });
    sendLocalized(client, msg, "chess.depthSet", { depth: depth });
    return;
  }

  if (command === "pvp") {
    await db("chats").coll.updateOne(
      { chatId },
      { $set: { "chess.mode": "pvp" } },
      { upsert: true },
    );
    return await sendLocalized(client, msg, "chess.modeSetPvp");
  }

  if (command === "pvc") {
    await db("chats").coll.updateOne(
      { chatId },
      { $set: { "chess.mode": "pvc" } },
      { upsert: true },
    );
    return await sendLocalized(client, msg, "chess.modeSetPvc");
  }

  sendLocalized(client, msg, "chess.help");
};
const printBoard = async (client: Client, chatId: string, chess: Chess) => {
  const imageGenerator = new ChessImageGenerator();
  await imageGenerator.loadFEN(chess.fen());
  const image: Buffer = await imageGenerator.generateBuffer();

  try {
    client.sendMessage(
      chatId,
      new MessageMedia("image/png", image.toString("base64"), chess.fen()),
    );
  } catch (e) {
    console.error("Error sending chess board image:", e);
  }
};

const makeComputerMove = async (
  client: Client,
  msg: Message, // Added msg parameter
  chatId: string,
  chess: Chess,
  depth = 15,
) => {
  const fen = chess.fen();
  const bestMove: string = await getBestMove(fen, depth);

  if (bestMove) {
    chess.move(bestMove);
    sendLocalized(client, msg, "chess.computerPlayed", { move: bestMove });
  } else {
    sendLocalized(client, msg, "chess.computerFailed");
  }
};

async function getBestMove(fen: string, depth = 15): Promise<string> {
  return await new Promise((resolve, reject) => {
    const stockfishPath = "/usr/games/stockfish";
    const stockfish = spawn(stockfishPath);
    const moves: string[] = [];
    let movesLength = 0;

    let bestMove = "";

    stockfish.stdout.on("data", (data) => {
      const output: string = data.toString();

      output.split("\n").forEach((line) => {
        if (line.includes("bestmove")) {
          const parts = line.split(" ");
          bestMove = parts[1].trim();
          moves.push(bestMove);
          // resolve(bestMove);
        }
      });
    });

    stockfish.stdout.on("exit", (code) => {
      if (code !== 0) {
        reject(`Stockfish exited with code ${code}.`);
      }
      // resolve(bestMove);
    });

    stockfish.stdin.write("uci\n");
    stockfish.stdin.write(`position fen ${fen}\n`);
    stockfish.stdin.write(`go depth ${depth}\n`);
    // stockfish.stdin.write("quit\n");

    (async () => {
      while (movesLength !== moves.length || moves.length == 0) {
        movesLength = moves.length;
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
      resolve(moves[moves.length - 1]);
    })();
  });
}

const command: Command = {
  name: "chess",
  command: "!chess",
  description: "chess.description",
  commandType: "plugin",
  isDependent: false,
  help: "chess.help",
  execute,
  public: true,
};

export default command;
