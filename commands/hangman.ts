import {
  getGroupLanguage,
  sendLocalized,
} from "../helpers/localizedMessenger.js";
import { getString } from "../helpers/i18n.js";
//jshint esversion:8
// code generated by chatgpt, fixed by wcyat
import { Client, Message } from "whatsapp-web.js";
import { Command } from "../types/command.js";
import axios from "../helpers/axios.js";
import fs from "fs";
import { ObjectId } from "mongodb";
import db from "../db/index.js";
import { getName } from "../helpers/getName.js";

const WORDLIST_FILE_PATH = "data/wordlist.txt";

let wordlist: string[] = [];

const downloadWordlist = async () => {
  const response = await axios.get(
    "https://raw.githubusercontent.com/Tom25/Hangman/master/wordlist.txt",
  );
  const words = response.data.split("\n");
  wordlist = words.filter((word: string) => /^[a-z]{5,20}$/i.test(word));
  fs.writeFileSync(WORDLIST_FILE_PATH, wordlist.join("\n"));
};

if (fs.existsSync(WORDLIST_FILE_PATH)) {
  wordlist = fs
    .readFileSync(WORDLIST_FILE_PATH, { encoding: "utf8" })
    .split("\n");
  wordlist = wordlist.filter((word) => /^[a-z]+$/i.test(word));
} else {
  downloadWordlist();
}

interface GameState {
  word: string;
  hiddenWord: string;
  guessedLetters: string[];
  guessesLeft: number;
}

interface GameDocument {
  _id?: ObjectId;
  chatId: string;
  gameState: GameState;
}

interface ScoreDocument {
  _id?: ObjectId;
  chatId: string;
  authorId: string;
  score: number;
}

const getRandomWord = (): string => {
  const randomIndex = Math.floor(Math.random() * wordlist.length);
  return wordlist[randomIndex];
};

const HANGMAN_STAGES: string[] = [
  `
  +---+
  |   |
      |
      |
      |
      |
=========`,
  `
  +---+
  |   |
  O   |
      |
      |
      |
=========`,
  `
  +---+
  |   |
  O   |
  |   |
      |
      |
=========`,
  `
  +---+
  |   |
  O   |
 /|   |
      |
      |
=========`,
  `
  +---+
  |   |
  O   |
 /|\\  |
      |
      |
=========`,
  `
  +---+
  |   |
  O   |
 /|\\  |
 /    |
      |
=========`,
  `
  +---+
  |   |
  O   |
 /|\\  |
 / \\  |
      |
=========`,
];

const execute = async (client: Client, msg: Message, args: string[]) => {
  const chatId = (await msg.getChat()).id._serialized;
  const authorId = msg.fromMe
    ? process.env.WTS_OWNER_ID
    : msg.author || msg.from;
  const contact = await msg.getContact();

  if (!wordlist.length) {
    await sendLocalized(client, msg, "hangman.wordlist_empty");
    return;
  }
  const hangmanCollection = db("hangman").coll;
  const hangmanScoreCollection = db("hangman-score").coll;
  const chatsCollection = db("chats").coll;
  const perPerson =
    (await chatsCollection.findOne({ chatId }))?.hangman?.perPerson || false;

  const query = {
    chatId,
    ...(perPerson && { authorId }),
  };

  switch (args[0]) {
    case "start": {
      if (await hangmanCollection.findOne(query)) {
        return await sendLocalized(client, msg, "hangman.game_in_progress", {
          mention: perPerson ? `@${contact.id.user} ` : "",
        });
      }
      const word = getRandomWord();
      const hiddenWord = word.replace(/\w/g, "_");
      const gameState: GameState = {
        word,
        hiddenWord,
        guessedLetters: [],
        guessesLeft: 6,
      };
      const gameDoc: GameDocument = { ...query, gameState };
      await hangmanCollection.insertOne(gameDoc);
      await sendLocalized(client, msg, "hangman.start.success", {
        mention: perPerson ? `@${contact.id.user} ` : "",
        wordLength: word.length,
        hiddenWord: hiddenWord,
      });
      break;
    }
    case "delete": {
      const game = (await hangmanCollection.findOne(query)) as GameDocument;
      if (game) {
        await hangmanCollection.deleteOne(query);
        return await sendLocalized(client, msg, "hangman.delete.success", {
          mention: perPerson ? `@${contact.id.user} ` : "",
          word: game.gameState.word,
        });
      }
      return await sendLocalized(client, msg, "hangman.delete.no_game");
    }
    case "config": {
      if (args[1] === "per-person") {
        await chatsCollection.updateOne(
          { chatId },
          { $set: { hangman: { perPerson: !perPerson } } },
          { upsert: true },
        );
        await hangmanCollection.deleteMany({ chatId });
        return await sendLocalized(
          client,
          msg,
          "hangman.config.per_person_toggle",
          {
            mention: perPerson ? `@${contact.id.user} ` : "",
            status: !perPerson
              ? getString("enabled", await getGroupLanguage(msg))
              : getString("disabled", await getGroupLanguage(msg)),
          },
        );
      } else {
        await sendLocalized(client, msg, "hangman.config.available", {
          mention: perPerson ? `@${contact.id.user} ` : "",
        });
      }
      break;
    }
    case "score": {
      if (!perPerson) {
        return await sendLocalized(
          client,
          msg,
          "hangman.score.per_person_disabled",
        );
      }
      const scores = (await hangmanScoreCollection
        .find({ chatId })
        .sort({ score: -1 })
        .limit(10)
        .toArray()) as ScoreDocument[];
      if (scores.length === 0) {
        return await sendLocalized(client, msg, "hangman.score.no_scores");
      }
      const targetLang = await getGroupLanguage(msg);
      const scoreMsg = `${getString("hangman.score.header", targetLang, {
        chatName: (await msg.getChat()).name,
      })}:\n${(
        await Promise.all(
          scores.map(async (v, i) => {
            return `${i + 1}. ${await getName(v.authorId)}: ${getString(
              "hangman.score.points",
              targetLang,
              { score: v.score },
            )}`;
          }),
        )
      ).join("\n")}`;

      await client.sendMessage(chatId, scoreMsg);
      break;
    }
    default: {
      for (const arg of args.slice(0, 2)) {
        const gameDoc = (await hangmanCollection.findOne(
          query,
        )) as GameDocument;
        if (!gameDoc) {
          await sendLocalized(client, msg, "hangman.no_game", {
            mention: perPerson ? `@${contact.id.user} ` : "",
          });
          return;
        }
        const gameState = gameDoc.gameState;
        const { word, guessedLetters, guessesLeft } = gameState;
        let { hiddenWord } = gameState;
        const letter = arg.toLowerCase();
        if (new RegExp(`^[a-z]{${gameState.word.length}}$`).test(letter)) {
          if (hiddenWord.split("").filter((i) => i === "_").length <= 1) {
            return await sendLocalized(
              client,
              msg,
              "hangman.guess.full_word_one_char_left",
              { mention: perPerson ? `@${contact.id.user} ` : "" },
            );
          }
          if (letter === word) {
            if (perPerson) {
              await hangmanScoreCollection.updateOne(
                { chatId, authorId },
                { $inc: { score: gameDoc.gameState.word.length } },
                { upsert: true },
              );
            }
            const scoreDocWin = perPerson
              ? await hangmanScoreCollection.findOne({ chatId, authorId })
              : null;
            const scoreWin = scoreDocWin ? scoreDocWin.score : 0;
            await sendLocalized(client, msg, "hangman.guess.win", {
              mention: perPerson ? `@${contact.id.user} ` : "",
              word: word,
              scoreMessage: perPerson
                ? getString(
                    "hangman.guess.win_score",
                    await getGroupLanguage(msg),
                    { score: scoreWin },
                  )
                : "",
            });
            await hangmanCollection.deleteOne(query);
            return;
          } else {
            await sendLocalized(client, msg, "hangman.guess.wrong_word", {
              mention: perPerson ? `@${contact.id.user} ` : "",
              letter: letter,
            });
            continue;
          }
        }
        if (!letter || !/^[a-z]$/.test(letter)) {
          await sendLocalized(client, msg, "hangman.guess.invalid_letter", {
            mention: perPerson ? `@${contact.id.user} ` : "",
          });
          continue;
        }
        if (guessedLetters.includes(letter)) {
          await sendLocalized(client, msg, "hangman.guess.already_guessed", {
            mention: perPerson ? `@${contact.id.user} ` : "",
            letter: letter,
          });
          continue;
        }
        guessedLetters.push(letter);
        if (word.includes(letter)) {
          for (let i = 0; i < word.length; i++) {
            if (word[i] === letter) {
              const hiddenWordArr = hiddenWord.split("");
              hiddenWordArr[i] = letter;
              hiddenWord = hiddenWordArr.join("");
            }
          }
          if (hiddenWord === word) {
            if (perPerson) {
              await hangmanScoreCollection.updateOne(
                { chatId, authorId },
                { $inc: { score: gameDoc.gameState.word.length } },
                { upsert: true },
              );
            }
            const scoreDocCorrect = perPerson
              ? await hangmanScoreCollection.findOne({ chatId, authorId })
              : null;
            const scoreCorrect = scoreDocCorrect ? scoreDocCorrect.score : 0;
            await sendLocalized(client, msg, "hangman.guess.win", {
              mention: perPerson ? `@${contact.id.user} ` : "",
              word: word,
              scoreMessage: perPerson
                ? getString(
                    "hangman.guess.win_score",
                    await getGroupLanguage(msg),
                    { score: scoreCorrect },
                  )
                : "",
            });
            await hangmanCollection.deleteOne(query);
            return;
          }
          gameState.hiddenWord = hiddenWord;
          await hangmanCollection.updateOne(query, { $set: { gameState } });
          await sendLocalized(client, msg, "hangman.guess.correct_letter", {
            mention: perPerson ? `@${contact.id.user} ` : "",
            letter: letter,
            hiddenWord: hiddenWord,
          });
        } else {
          if (guessesLeft <= 1) {
            await sendLocalized(client, msg, "hangman.guess.lose", {
              mention: perPerson ? `@${contact.id.user} ` : "",
              word: word,
              hangmanStage: HANGMAN_STAGES[6],
            });
            await hangmanCollection.deleteOne(query);
            return;
          }
          gameState.guessesLeft = guessesLeft - 1;
          const remainingGuesses = gameState.guessesLeft;
          gameState.guessedLetters = guessedLetters;
          await hangmanCollection.updateOne(query, { $set: { gameState } });
          const hangmanStage = HANGMAN_STAGES[6 - remainingGuesses];
          await sendLocalized(client, msg, "hangman.guess.wrong_letter", {
            mention: perPerson ? `@${contact.id.user} ` : "",
            letter: letter,
            remainingGuesses: remainingGuesses,
            hangmanStage: hangmanStage,
            hiddenWord: hiddenWord,
          });
        }
      }
      break;
    }
  }
};

const command: Command = {
  name: "hangman",
  command: "!hangman",
  description: "hangman.description",
  commandType: "plugin",
  isDependent: false,
  help: "hangman.help",
  execute,
  public: true,
};

export default command;
